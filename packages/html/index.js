/* eslint no-sync:0, no-console:0, no-param-reassign:0, max-statements:0, max-lines-per-function:0 */

// core modules
const path = require('path');

// dep modules
const { minify } = require('html-minifier');

// own modules
const pkg = require('./package.json');
const { OCLI, Styles, utils } = require('@ocli/core');
const { fs } = utils;

const ocli = new OCLI('HTML');
const s = new Styles(true);
const { log } = ocli;

const htmlMinDefaultOpts = {
    caseSensitive: true,
    collapseBooleanAttributes: false,
    collapseInlineTagWhitespace: false,
    collapseWhitespace: false,
    conservativeCollapse: true,
    customAttrAssign: [],
    customAttrCollapse: undefined,
    customAttrSurround: [],
    customEventAttributes: [],
    decodeEntities: false,
    html5: true,
    ignoreCustomComments: [/^!/],
    ignoreCustomFragments: [/<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/],
    includeAutoGeneratedTags: false,
    keepClosingSlash: true,
    maxLineLength: undefined,
    minifyCSS: false,
    minifyJS: false,
    minifyURLs: false,
    preserveLineBreaks: false,
    preventAttributesEscaping: true,
    processConditionalComments: false,
    processScripts: [],
    quoteCharacter: '"',
    removeAttributeQuotes: false,
    removeComments: false,
    removeEmptyAttributes: false,
    removeEmptyElements: false,
    removeOptionalTags: false,
    removeRedundantAttributes: false,
    removeScriptTypeAttributes: false,
    removeStyleLinkTypeAttributes: false,
    removeTagWhitespace: false,
    sortAttributes: false,
    sortClassName: false,
    trimCustomFragments: false,
    useShortDoctype: false
};

const defaultOptions = {
    decode: false,
    html5: false,
    minify: false,
    css: false,
    js: false,
    fragments: [/<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/],
    parents: false, // boolean (for all parent dirs) or number for limiting levels
    overwrite: false, // fs-extra
    errorOnExists: true,
    dereference: false, // fs-extra but also globs option as followSymlinkedDirectories
    cwd: process.cwd(), // fs-x and globs option
    dot: false // globs option
};

function getHtmlMinOpts(opts) {
    return {
        ...htmlMinDefaultOpts,
        collapseBooleanAttributes: Boolean(opts.minify),
        collapseInlineTagWhitespace: Boolean(opts.minify),
        collapseWhitespace: Boolean(opts.minify),
        decodeEntities: Boolean(opts.decode),
        ignoreCustomFragments: !opts.fragments ? defaultOptions.fragments : opts.fragments,
        keepClosingSlash: !opts.minify,
        minifyCSS: Boolean(opts.css),
        minifyJS: Boolean(opts.js),
        removeComments: Boolean(opts.minify),
        removeRedundantAttributes: Boolean(opts.minify),
        removeScriptTypeAttributes: Boolean(opts.minify),
        removeStyleLinkTypeAttributes: Boolean(opts.minify),
        html5: Boolean(opts.html5),
        useShortDoctype: Boolean(opts.html5)
    };
}

// src is a file and dest is a directory
async function htmlOne(src, dest, options) {
    // htmlOne is never called directly, so we're sure we have options set.
    src = path.resolve(options.cwd, src);

    const basename = path.basename(src);

    if (dest) {
        if (options.parents) {
            const p = path.relative(options.cwd, path.dirname(src));
            // if source is outside of cwd; normally, it ends up outside of dest
            // dir when parents = true. so we'll check for "../" (or "..\\" on
            // windows) and never write outside of dest dir.
            const isOutsideOfCwd = p.includes('..');
            let parents = isOutsideOfCwd ? '' : p;
            if (parents && typeof options.parents === 'number' && options.parents > 0) {
                parents = utils.getParents(parents, options.parents, path.sep);
            }
            dest = path.join(dest, parents);
        }
    } else {
        // If dest is omitted, directory of the source file is used. This
        // results in overwriting the source file, if --overwrite option is
        // set.
        dest = path.dirname(src);
    }

    // dest dir
    await fs.ensureDir(dest);
    // dest file
    dest = path.join(dest, basename);

    if (!options.overwrite) {
        if (await fs.pathExists(dest)) {
            if (options.errorOnExists) ocli.fail(`HTML file already exists: ${dest}`);
            log.warn(`HTML file already exists. Will not overwrite: ${dest}`);
            return false;
        }
    }

    const htmlMinOpts = getHtmlMinOpts(options);
    // console.log('htmlMinOpts', htmlMinOpts);
    let content = await fs.readFile(src, 'utf8');
    content = await minify(content, htmlMinOpts);
    await fs.writeFile(dest, content, 'utf8');
    return true;
}

const describe = 'Process, minify HTML file(s).';
const cmdOptionsMeta = {
    d: {
        alias: 'decode',
        describe: 'Use Unicode characters whenever possible',
        type: 'boolean',
        // default: false,
        global: false
    },
    H: {
        alias: 'html5',
        describe: 'Parse input according to HTML5 specifications',
        type: 'boolean',
        // default: false,
        global: false
    },
    m: {
        alias: 'minify',
        describe: 'Minify HTML file(s).',
        type: 'boolean',
        // default: false,
        global: false
    },
    f: {
        alias: 'fragments',
        describe: 'Array of regex\'es that allow to ignore certain fragments, when matched (e.g. <?php ... ?>, {{ ... }}, etc.)',
        type: 'string',
        // default: undefined,
        global: false
    },
    C: {
        alias: 'css',
        describe: 'Minify CSS in style elements and style attributes',
        type: 'boolean',
        // default: false,
        global: false
    },
    j: {
        alias: 'js',
        describe: 'Minify JavaScript in script elements and event attributes',
        type: 'boolean',
        // default: false,
        global: false
    },
    c: {
        alias: 'config',
        type: 'string',
        description: 'Path to a JSON configuration file for batch HTML operations as a task. When set, all other CLI options are ignored. They should be defined in the config file.',
        global: false,
        normalize: true // apply path.normalize
    },
    p: {
        alias: 'parents',
        describe: 'Also create parent directory structure. Redundant if `dest` is not set.',
        type: 'boolean',
        global: false
    },
    o: {
        alias: 'overwrite',
        describe: 'Overwrite the destination if exists.',
        type: 'boolean',
        global: false
    },
    e: {
        alias: 'error-on-exists',
        describe: 'Throw if overwrite is false and file exists.',
        type: 'boolean',
        global: false
    },
    deref: {
        alias: 'dereference',
        type: 'boolean',
        description: 'Dereference symlinks.',
        global: false
    }
};

// builder function used to provide advanced command specific help.
/* istanbul ignore next */
function builder(yargs) {
    return yargs
        .usage(`\n${s.accent('o')} ${s.accent('html')} ${s.white('[src]')} ${s.white('[dest]')}\n\n${describe}`)
        .help('h', `Show ${pkg.name} help`).alias('h', 'help')
        .version('v', `Output ${pkg.name} version`, pkg.version)
        .alias('v', 'version')
        .positional('src', {
            describe: 'Source file paths or globs. Can be comma-separated if multiple.',
            type: 'string'
        })
        .positional('dest', {
            describe: 'Destination directory. If omitted, directory of the source file is used. This results in overwriting the source file, if --overwrite is set.',
            type: 'string'
        })
        // .implies('src', 'dest')
        .conflicts('config', ['src'])
        .group('config', s.subtitle('Run an HTML task from config:'))
        // see https://github.com/kangax/html-minifier
        .options(cmdOptionsMeta)
        .example(
            `${s.hilight('o html')} ${s.white('src/**/*.html dest/')} ${s.opt('-m -H -p')}`,
            s.faded('Parse (with HTML5 specs) & minify HTML files, write to dest with parent dirs')
        )
        .example(
            `${s.hilight('o html')} ${s.opt('-c')} ${s.white('path/to/html.config.json')}`,
            s.faded('Process HTML files from a JSON config file')
        );
}

// handler will be executed with the parsed argv object.
function handler(argv) {

    if (argv.config) {
        /* istanbul ignore next */
        if (argv.src || argv.dest) {
            log.warn('Running from batch config file. `src` and `dest` paramters are ignored.');
        }
        return ocli.fn(argv.config);
    }
    if (argv.src) {
        const options = utils.pickOptsFromArgv(argv, cmdOptionsMeta);
        return ocli.fn(argv.src, argv.dest, options);
    }

    log.warn('Please either provide `src` (and `dest`) parameter or `--config` option.');
    log.warn('Run `do html --help` to get help.');
    return Promise.resolve(null);
}

module.exports = ocli.define(htmlOne, {
    batchProcess: {
        defaultOptions,
        verb: 'Wrote',
        useGlobs: true,
        files: true,
        directories: false
    },
    command: ['html [src] [dest]'],
    describe,
    builder,
    handler
});
